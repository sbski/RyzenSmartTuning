
<cpu_events>

<!--
       Family 12h Microarchitecture performance monitor events (preliminary)

       Source: BIOS and Kernel Developer's Guide for the AMD Family 12h
       Processors, Rev 1.13, March 01, 2011

       Copyright (c) 2011 Advanced Micro Devices, Inc.
       Last Modified: 9 March 2011
-->

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; FP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

<source unit="FP">

<event name="Dispatched FPU Operations" abbreviation="FPU ops" value="0" >
	<mask value="0" name="Add pipe ops excluding load ops and SSE move ops" />
	<mask value="1" name="Multiply pipe ops excluding load ops and SSE move ops" />
	<mask value="2" name="Store pipe ops excluding load ops and SSE move ops" />
	<mask value="3" name="Add pipe load ops and SSE move ops" />
	<mask value="4" name="Multiply pipe load ops and SSE move ops" />
	<mask value="5" name="Store pipe load ops and SSE move ops" />
	<op_name name="op" value="DISPATCHED_FPU_OPS" />
	<description>The number of operations (uops) dispatched to the FPU execution pipelines. This event reflects how busy the FPU pipelines are. This includes all operations done by x87, MMXTM and SSE instructions, including moves. Each increment represents a one-cycle dispatch event; packed 128-bit SSE operations count as two ops in 64-bit FPU implementations; scalar operations count as one. This event is a speculative event. (See PMCx0CB). Since this event includes non-numeric operations it is not suitable for measuring MFLOPs.</description>
</event>

<event name="Cycles in which the FPU is Empty" abbreviation="Cycles FPU emtpy" value="1" >
	<op_name name="op" value="CYCLES_FPU_EMPTY" />
	<description>The number of cycles in which the FPU is empty. Invert this (MSRC001_00[03:00][Invert]=1) to count cycles in which at least one FPU operation is present in the FPU.</description>
</event>

<event name="Dispatched Fast Flag FPU Operations" abbreviation="Fast flag FPU ops" value="2" >
	<op_name name="op" value="DISPATCHED_FPU_OPS_FAST_FLAG" />
	<description>The number of FPU operations that use the fast flag interface (e.g. FCOMI, COMISS, COMISD, UCOMISS, UCOMISD, MOVD, CVTSD2SI). This event is a speculative event.</description>
</event>

<event name="Retired SSE Operations" abbreviation="Retired SSE Ops" value="3" >
	<mask value="0" name="Single precision add/subtract ops" />
	<mask value="1" name="Single precision multiply ops" />
	<mask value="2" name="Single precision divide/square root ops" />
	<mask value="3" name="Double precision add/subtract ops" />
	<mask value="4" name="Double precision multiply ops" />
	<mask value="5" name="Double precision divide/square root ops" />
	<mask value="6" name="Op type: 0=uops. 1=FLOPS" />
	<op_name name="op" value="RETIRED_SSE_OPS" />
	<description>The number of SSE operations retired. This counter can count either FLOPS (UnitMask bit 6 = 1) or uops (UnitMask bit 6 = 0).</description>
</event>

<event name="Retired Move Ops" abbreviation="Ret move ops" value="4" >
	<mask value="0" name="Merging low quadword move uops" />
	<mask value="1" name="Merging high quadword move uops" />
	<mask value="2" name="All other merging move uops" />
	<mask value="3" name="All other move uops" />
	<op_name name="op" value="RETIRED_MOVE_OPS" />
	<description>The number of move uops retired. Merging low quadword move ops copy the lower 64 bits of a source register to the upper 64 bits of a destination register. The lower 64 bits of the destination register remain unchanged. Merging high quadword move ops copy the upper 64 bits of a source register to the lower 64 bits of a destination register. The upper 64 bits of the destination register remain unchanged.</description>
</event>

<event name="Retired Serializing Ops" abbreviation="Ret serializing ops" value="5" >
	<mask value="0" name="SSE bottom-executing uops retired" />
	<mask value="1" name="SSE bottom-serializing uops retired" />
	<mask value="2" name="x87 bottom-executing uops retired" />
	<mask value="3" name="x87 bottom-serializing uops retired" />
	<op_name name="op" value="RETIRED_SERIALIZING_OPS" />
	<description>The number of serializing uops retired. A bottom-executing uop is not issued until it is the oldest non-retired uop in the FPU. Bottom-executing ops are most commonly seen with FSTSW and STMXCSR instructions. A bottom-serializing uop does not issue until it is the oldest non-issued uop in the FP scheduler. Bottom-serializing uops block all subsequent uops from being issued until the uop is issued. Bottom-serializing ops are most commonly seen with FLCDW and LDMXCSR instructions.</description>
</event>

<event name="Number of Cycles that a Serializing uop is in the FP Scheduler" abbreviation="Serialized uop cycles" value="6" >
	<mask value="0" name="Number of cycles a bottom-execute uop is in the FP scheduler" />
	<mask value="1" name="Number of cycles a bottom-serializing uop is in the FP scheduler" />
	<op_name name="op" value="SERIAL_UOPS_IN_FP_SCHED" />
	<description>See PMCx005 for a description of bottom-executing and bottom-serializing uop.</description>
</event>

</source>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

<source unit="LS">

<event name="Segment Register Loads" abbreviation="Seg reg loads" value="20" >
	<mask value="0" name="ES" />
	<mask value="1" name="CS" />
	<mask value="2" name="SS" />
	<mask value="3" name="DS" />
	<mask value="4" name="FS" />
	<mask value="5" name="GS" />
	<mask value="6" name="HS" />
	<op_name name="op" value="SEGMENT_REGISTER_LOADS" />
	<description>The number of segment register loads performed.</description>
</event>

<event name="Pipeline Restart Due to Self-Modifying Code" abbreviation="Restart self-mod code" value="21" >
	<op_name name="op" value="PIPELINE_RESTART_DUE_TO_SELF_MODIFYING_CODE" />
	<description>The number of pipeline restarts caused by self-modifying code (a store that hits any instruction that has been fetched for execution beyond the instruction doing the store).</description>
</event>

<event name="Pipeline Restart Due to Probe Hit" abbreviation="Restart probe hit" value="22" >
	<op_name name="op" value="PIPELINE_RESTART_DUE_TO_PROBE_HIT" />
	<description>The number of pipeline restarts caused by an invalidating probe hitting on a speculative out-of-order load.</description>
</event>

<event name="LS Buffer 2 Full" abbreviation="LS buffer2 full" value="23" >
	<op_name name="op" value="LS_BUFFER_2_FULL_CYCLES" />
	<description>The number of cycles that the LS2 buffer is full. This buffer holds stores waiting to retire as well as requests that missed the data cache and are waiting on a refill. This condition stalls further data cache accesses, although such stalls may be overlapped by independent instruction execution.</description>
</event>

<event name="Locked Operations" abbreviation="Locked ops" value="24" >
	<mask value="0" name="Number of locked instructions executed" />
	<mask value="1" name="Number of cycles spent in speculative phase" />
	<mask value="2" name="Number of cycles spent in non-speculative phase (including cache miss penalty)" />
	<mask value="3" name="Number of cycles waiting for a cache hit (cache miss penalty)" />
	<op_name name="op" value="LOCKED_OPS" />
	<description>This event covers locked operations performed and their execution time. The execution time represented by the cycle counts is typically overlapped to a large extent with other instructions. The non-speculative cycles event is suitable for event-based profiling of lock operations that tend to miss in the cache.</description>
</event>

<event name="Retired CLFLUSH Instructions" abbreviation="Ret CLFLUSH inst" value="26" >
	<op_name name="op" value="RETIRED_CLFLUSH_INSTRUCTIONS" />
	<description>The number of CLFLUSH instructions retired.</description>
</event>

<event name="Retired CPUID Instructions" abbreviation="Ret CPUID inst" value="27" >
	<op_name name="op" value="RETIRED_CPUID_INSTRUCTIONS" />
	<description>The number of CPUID instructions retired.</description>
</event>

<event name="Cancelled Store to Load Forward Operations" abbreviation="Cancelled fwd ops" value="2a" >
	<mask value="0" name="Address mismatches (starting byte not the same)" />
	<mask value="1" name="Store is smaller than load" />
	<mask value="2" name="Misaligned" />
	<op_name name="op" value="CANCELLED_STORE_TO_LOAD" />
	<description>Counts the number store to load forward operations that are cancelled.</description>
</event>

<event name="SMIs Received" abbreviation="SMIs received" value="2b" >
	<op_name name="op" value="SMIS_RECEIVED" />
	<description>Counts the number of SMIs received by the processor.</description>
</event>

</source>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

<source unit="DC">

<event name="Data Cache Accesses" abbreviation="DC accesses" value="40" >
	<op_name name="op" value="DATA_CACHE_ACCESSES" />
	<description>The number of accesses to the data cache for load and store references. This may include certain microcode scratchpad accesses, although these are generally rare. Each increment represents an eight-byte access, although the instruction may only be accessing a portion of that. This event is a speculative event.</description>
</event>

<event name="Data Cache Misses" abbreviation="DC misses" value="41" >
	<op_name name="op" value="DATA_CACHE_MISSES" />
	<description>The number of data cache references which missed in the data cache. This event is a speculative event.</description>
</event>

<event name="Data Cache Refills from L2 or Northbridge" abbreviation="DC refills L2/NB" value="42" >
	<mask value="0" name="Refill from the northbridge" />
	<mask value="1" name="Shared-state line from L2" />
	<mask value="2" name="Exclusive-state line from L2" />
	<mask value="3" name="Owned-state line from L2" />
	<mask value="4" name="Modified-state line from L2" />
	<op_name name="op" value="DATA_CACHE_REFILLS_FROM_L2_OR_NORTHBRIDGE" />
	<description>The number of data cache refills satisfied from the L2 cache (and/or the northbridge), per the UnitMask. Unit-Mask bits 4:1 allow a breakdown of refills from the L2 by coherency state. UnitMask bit 0 reflects refills which missed in the L2, and provides the same measure as the combined sub-events of PMCx043. Each increment reflects a 64-byte transfer. This event is a speculative event.</description>
</event>

<event name="Data Cache Refills from the Northbridge" abbreviation="DC refills NB" value="43" >
	<mask value="0" name="Invalid" />
	<mask value="1" name="Shared" />
	<mask value="2" name="Exclusive" />
	<mask value="3" name="Owned" />
	<mask value="4" name="Modified" />
	<op_name name="op" value="DATA_CACHE_REFILLS_FROM_NORTHBRIDGE" />
	<description>The number of L1 cache refills satisfied from the northbridge (DRAM or another processor's cache), as opposed to the L2. The UnitMask selects lines in one or more specific coherency states. Each increment reflects a 64-byte transfer. This event is a speculative event.</description>
</event>

<event name="Data Cache Lines Evicted" abbreviation="DC evicted" value="44" >
	<mask value="0" name="Invalid" />
	<mask value="1" name="Shared" />
	<mask value="2" name="Exclusive" />
	<mask value="3" name="Owned" />
	<mask value="4" name="Modified" />
	<mask value="5" name="Evicted line brought into cache by a PrefetchNTA instruction" />
	<mask value="6" name="Evicted line not brought into cache by PrefetchNTA instruction" />
	<op_name name="op" value="DATA_CACHE_LINES_EVICTED" />
	<description>The number of L1 data cache lines written to the L2 cache or system memory, having been displaced by L1 refills. The UnitMask may be used to count only victims in specific coherency states. Each increment represents a 64-byte transfer. This event is a speculative event. In most cases, L1 victims are moved to the L2 cache, displacing an older cache line there. Lines brought into the data cache by PrefetchNTA instructions, however, are evicted directly to system memory (if dirty) or invalidated (if clean). The Invalid case (UnitMask[0]) reflects the replacement of lines that would have been invalidated by probes for write operations from another processor or DMA activity. UnitMask[2,1] count all evictions regardless of cache line state. When either UnitMask[2 or 1] is enabled all other UnitMasks should be disabled.</description>
</event>

<event name="L1 DTLB Miss and L2 DTLB Hit" abbreviation="DTLB L1M L2H" value="45" >
	<mask value="0" name="L2 4K TLB hit" />
	<mask value="1" name="L2 2M TLB hit" />
	<mask value="2" name="L2 1G TLB hit" />
	<op_name name="op" value="L1_DTLB_MISS_AND_L2_DTLB_HIT" />
	<description>The number of data cache accesses that miss in the L1 DTLB and hit in the L2 DTLB. This event is a speculative event.</description>
</event>

<event name="L1 DTLB and L2 DTLB Miss" abbreviation="DTLB L1M L2M" value="46" >
	<mask value="0" name="4K TLB reload" />
	<mask value="1" name="2M TLB reload" />
	<mask value="2" name="1G TLB reload" />
	<op_name name="op" value="L1_DTLB_AND_L2_DTLB_MISS" />
	<description>The number of data cache accesses that miss in both the L1 and L2 DTLBs. This event is a speculative event.</description>
</event>

<event name="Misaligned Accesses" abbreviation="Misalign access" value="47" >
	<op_name name="op" value="MISALIGNED_ACCESSES" />
	<description>The number of data cache accesses that are misaligned. These are accesses which cross a sixteen-byte boundary. They incur an extra cache access (reflected in PMCx040), and an extra cycle of latency on reads. This event is a speculative event.</description>
</event>

<event name="Microarchitectural Late Cancel of an Access" abbreviation="Late cancel" value="48" >
	<op_name name="op" value="MICRO_ARCH_LATE_CANCEL_ACCESS" />
	<description>Microarchitectural Late Cancel of an Access.</description>
</event>

<event name="Microarchitectural Early Cancel of an Access" abbreviation="Early cancel" value="49" >
	<op_name name="op" value="MICRO_ARCH_EARLY_CANCEL_ACCESS" />
	<description>Microarchitectural Early Cancel of an Access.</description>
</event>

<event name="Prefetch Instructions Dispatched" abbreviation="Prefetch inst" value="4b" >
	<mask value="0" name="Load (Prefetch, PrefetchT0/T1/T2)" />
	<mask value="1" name="Store (PrefetchW)" />
	<mask value="2" name="NTA (PrefetchNTA)" />
	<op_name name="op" value="PREFETCH_INSTRUCTIONS_DISPATCHED" />
	<description>The number of prefetch instructions dispatched by the decoder. Such instructions may or may not cause a cache line transfer. All Dcache and L2 accesses, hits and misses by prefetch instructions, except for prefetch instructions that collide with an outstanding hardware prefetch, are included in these events. This event is a speculative event.</description>
</event>

<event name="DCACHE Misses by Locked Instructions" abbreviation="DC misses locked inst" value="4c" >
	<mask value="1" name="Data cache misses by locked instructions" />
	<op_name name="op" value="LOCKED_INSTRUCTIONS_DCACHE_MISSES" />
	<description>The number of data cache misses incurred by locked instructions. (The total number of locked instructions may be obtained from PMCx024.) Such misses may be satisfied from the L2 or system memory, but there is no provision for distinguishing between the two. When used for event-based profiling, this event tends to occur very close to the offending instructions. This event is also included in the basic Dcache miss event (PMCx041).</description>
</event>

<event name="L1 DTLB Hit" abbreviation="L1 DTLB hit" value="4d" >
	<mask value="0" name="L1 4K TLB hit" />
	<mask value="1" name="L1 2M TLB hit" />
	<mask value="2" name="L1 1G TLB hit" />
	<op_name name="op" value="L1_DTLB_HIT" />
	<description>The number of data cache accesses that hit in the L1 DTLB. This event is a speculative event.</description>
</event>

<event name="Ineffective Software Prefetches" abbreviation="Ineffective SW prefetch" value="52" >
	<mask value="0" name="Software prefetch hit in the L1" />
	<mask value="3" name="Software prefetch hit in L2" />
	<op_name name="op" value="INEFFECTIVE_SW_PREFETCHES" />
	<description>The number of software prefetches that did not fetch data outside of the processor core.</description>
</event>

<event name="Global TLB Flushes" abbreviation="Global TLB flushes" value="54" >
	<op_name name="op" value="GLOBAL_TLB_FLUSHES" />
	<description>This event counts TLB flushes that flush TLB entries that have the global bit set.</description>
</event>

</source>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; BU
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

<source unit="BU">

<event name="Memory Requests by Type" abbreviation="Memory req" value="65" >
	<mask value="0" name="Requests to non-cacheable (UC) memory" />
	<mask value="1" name="Requests to write-combining (WC) memory or WC buffer flushes to WB memory" />
	<mask value="2" name="Requests to cache-disabled (CD) memory" />
	<mask value="7" name="Streaming store (SS) requests" />
	<op_name name="op" value="MEMORY_REQUESTS" />
	<description>These events reflect accesses to uncacheable (UC) or write-combining (WC) memory regions (as defined by MTRR or PAT settings) and Streaming Store activity to WB memory. Both the WC and Streaming Store events reflect Write Combining buffer flushes, not individual store instructions. WC buffer flushes which typically consist of one 64-byte write to the system for each flush (assuming software typically fills a buffer before it gets flushed). A partially-filled buffer requires two or more smaller writes to the system. The WC event reflects flushes of WC buffers that are filled by stores to WC memory or streaming stores to WB memory. The Streaming Store event reflects only flushes due to streaming stores (which are typically only to WB
memory). The difference between counts of these two events reflects the true amount of write events to WC memory.</description>
</event>

<event name="Data Prefetcher" abbreviation="Data prefetcher" value="67" >
	<mask value="0" name="Cancelled prefetches" />
	<mask value="1" name="Prefetch attempts" />
	<op_name name="op" value="DATA_PREFETCHES" />
	<description>These events reflect requests made by the data prefetcher. UnitMask[1] counts total prefetch requests, while bit 0 counts requests where the target block is found in the L2 or data cache. The difference between the two represents actual data read (in units of 64-byte cache lines) from the system by the prefetcher. This is also included in the count of PMCx07F, UnitMask[0] (combined with other L2 fill events).</description>
</event>

<event name="Northbridge Read Responses by Coherency State" abbreviation="NB read resp coh state" value="6c" >
	<mask value="0" name="Exclusive" />
	<mask value="1" name="Modified" />
	<mask value="2" name="Shared" />
	<mask value="3" name="Owned" />
	<mask value="4" name="Data Error" />
	<op_name name="op" value="NORTHBRIDGE_READ_RESPONSES" />
	<description>The number of responses from the Northbridge for cache refill requests. The UnitMask may be used to select specific cache coherency states. Each increment represents one 64-byte cache line transferred from the Northbridge (DRAM or another cache) to the data cache, instruction cache or L2 cache (for data prefetcher and TLB table walks). Modified-state responses may be for Dcache store miss refills, PrefetchW software prefetches, hardware prefetches for a store-miss stream, or Change-to-Dirty requests that get a dirty (Owned) probe hit in another cache. Exclusive responses may be for any Icache refill, Dcache load miss refill, other software prefetches, hardware prefetches for a load-miss stream, or TLB table walks that miss in the L2 cache; Shared responses may be for any of those that hit a clean line in another cache.</description>
</event>

<event name="Octwords Written to System" abbreviation="Octwords written to sys" value="6d" >
	<mask value="0" name="Octword write transfer" />
	<op_name name="op" value="OCTWORD_WRITE_TRANSFERS" />
	<description>The number of octword (16-byte) data transfers from the processor to the system. These may be part of a 64-byte cache line writeback or a 64-byte dirty probe hit response, each of which would cause four increments; or a partial or complete Write Combining buffer flush (Sized Write), which could cause from one to four increments.</description>
</event>

<event name="CPU Clocks not Halted" abbreviation="CPU clocks" value="76" >
	<op_name name="op" value="CPU_CLK_UNHALTED" />
	<description>The number of clocks that the CPU is not in a halted state (due to STPCLK or a HALT instruction). This event allows system idle time to be automatically factored out from IPC (or CPI) measurements, providing the OS halts the CPU when going idle. If the OS goes into an idle loop rather than halting, such calculations are influenced by the IPC of the idle loop.</description>
</event>

<event name="Requests to L2 Cache" abbreviation="L2 requests" value="7d" >
	<mask value="0" name="IC fill" />
	<mask value="1" name="DC fill" />
	<mask value="2" name="TLB fill (page table walks)" />
	<mask value="3" name="Tag snoop request" />
	<mask value="4" name="Cancelled request" />
	<mask value="5" name="Hardware prefetch from DC" />
	<op_name name="op" value="REQUESTS_TO_L2" />
	<description>The number of requests to the L2 cache for Icache or Dcache fills, or page table lookups for the TLB. These events reflect only read requests to the L2. These include some amount of retries associated with address or resource conflicts. Such retries tend to occur more as the L2 gets busier, and in certain extreme cases (such as large block moves that overflow the L2) these extra requests can dominate the event count. These extra requests are not a direct indication of performance impact - they simply reflect opportunistic accesses that don't complete. But because of this, they are not a good indication of actual cache line movement. The Icache and Dcache miss and refill events (81h, 82h, 83h, 41h, 42h, 43h) provide a more accurate indication of this, and are the preferred way to measure such traffic.</description>
</event>

<event name="L2 Cache Misses" abbreviation="L2 misses" value="7e" >
	<mask value="0" name="IC fill" />
	<mask value="1" name="DC fill (includes possible replays, whereas PMCx041 does not)" />
	<mask value="2" name="TLB page table walk" />
	<mask value="3" name="Hardware prefetch from DC" />
	<op_name name="op" value="L2_CACHE_MISS" />
	<description>The number of requests that miss in the L2 cache. This may include some amount of speculative activity, as well as some amount of retried requests as described in PMCx07D. The IC-fill-miss and DC-fill-miss events tend to mirror the Icache and Dcache refill-from-system events (83h and PMCx043, respectively), and tend to include more speculative activity than those events.</description>
</event>

<event name="L2 Fill/Writeback" abbreviation="L2 fill/writeback" value="7f" >
	<mask value="0" name="L2 fills" />
	<mask value="1" name="L2 Writebacks to system" />
	<op_name name="op" value="L2_CACHE_FILL_WRITEBACK" />
	<description>The number of lines written into the L2 cache due to victim writebacks from the Icache or Dcache, TLB page table walks and the hardware data prefetcher (UnitMask[0]); or writebacks of dirty lines from the L2 to the system (UnitMask[1]). Each increment represents a 64-byte cache line transfer. Victim writebacks from the Dcache may be measured separately using PMCx044. However this is not quite the same as the Dcache component of this event, the main difference being PrefetchNTA lines. When these are evicted from the Dcache due to replacement, they are written out to system memory (if dirty) or simply invalidated (if clean), rather than being moved to the L2 cache.</description>
</event>

<event name="Page Size Mismatches" abbreviation="Page size mismatches" value="165" >
	<mask value="0" name="Guest page size is larger than the host page size" />
	<mask value="1" name="MTRR mismatch" />
	<mask value="2" name="Host page size is larger than the guest page size" />
	<op_name name="op" value="PAGE_SIZE_MISMATCHES" />
	<description>Counts the number of large pages that are installed into the TLB as a smaller page size.</description>
</event>

</source>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; IC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

<source unit="IC">

<event name="Instruction Cache Fetches" abbreviation="IC fetches" value="80" >
	<op_name name="op" value="INSTRUCTION_CACHE_FETCHES" />
	<description>The number of instruction cache accesses by the instruction fetcher. Each access is an aligned 32 byte read, from which a varying number of instructions may be decoded.</description>
</event>

<event name="Instruction Cache Misses" abbreviation="IC misses" value="81" >
	<op_name name="op" value="INSTRUCTION_CACHE_MISSES" />
	<description>The number of instruction fetches and prefetch requests that miss in the instruction cache. This is typically equal to or very close to the sum of events 82h and 83h. Each miss results in a 64-byte cache line refill.</description>
</event>

<event name="Instruction Cache Refills from L2" abbreviation="IC refills from L2" value="82" >
	<op_name name="op" value="INSTRUCTION_CACHE_REFILLS_FROM_L2" />
	<description>The number of instruction cache refills satisfied from the L2 cache. Each increment represents one 64-byte cache line transfer.</description>
</event>

<event name="Instruction Cache Refills from System" abbreviation="IC refills from sys" value="83" >
	<op_name name="op" value="INSTRUCTION_CACHE_REFILLS_FROM_SYSTEM" />
	<description>The number of instruction cache refills from system memory (or another cache). Each increment represents one 64-byte cache line transfer.</description>
</event>

<event name="L1 ITLB Miss, L2 ITLB Hit" abbreviation="ITLB L1M L2H" value="84" >
	<op_name name="op" value="L1_ITLB_MISS_AND_L2_ITLB_HIT" />
	<description>The number of instruction fetches that miss in the L1 ITLB but hit in the L2 ITLB.</description>
</event>

<event name="L1 ITLB Miss, L2 ITLB Miss" abbreviation="ITLB L1M L2M" value="85" >
	<mask value="0" name="Instruction fetches to a 4K page" />
	<mask value="1" name="Instruction fetches to a 2M page" />
	<op_name name="op" value="L1_ITLB_MISS_AND_L2_ITLB_MISS" />
	<description>The number of instruction fetches that miss in both the L1 and L2 ITLBs.</description>
</event>

<event name="Pipeline Restart Due to Instruction Stream Probe" abbreviation="Restart i-stream probe" value="86" >
	<op_name name="op" value="PIPELINE_RESTART_DUE_TO_INSTRUCTION_STREAM_PROBE" />
	<description>The number of pipeline restarts caused by invalidating probes that hit on the instruction stream currently being executed. This would happen if the active instruction stream was being modified by another processor in an MP system - typically a highly unlikely event.</description>
</event>

<event name="Instruction Fetch Stall" abbreviation="Inst fetch stall" value="87" >
	<op_name name="op" value="INSTRUCTION_FETCH_STALL" />
	<description>The number of cycles the instruction fetcher is stalled. This may be for a variety of reasons such as branch predictor updates, unconditional branch bubbles, far jumps and cache misses, among others. May be overlapped by instruction dispatch stalls or instruction execution, such that these stalls don't necessarily impact performance.</description>
</event>

<event name="Return Stack Hits" abbreviation="RET stack hits" value="88" >
	<op_name name="op" value="RETURN_STACK_HITS" />
	<description>The number of near return instructions (RET or RET Iw) that get their return address from the return address stack (i.e. where the stack has not gone empty). This may include cases where the address is incorrect (return mispredicts). This may also include speculatively executed false-path returns. Return mispredicts are typically caused by the return address stack underflowing, however they may also be caused by an imbalance in calls vs. returns, such as doing a call but then popping the return address off the stack. This event cannot be reliably compared with events C9h and CAh (such as to calculate percentage of return mispredicts due to an empty return address stack), since it may include speculatively executed false-path returns that are not included in those retire-time events.</description>
</event>

<event name="Return Stack Overflows" abbreviation="RET stack overflows" value="89" >
	<op_name name="op" value="RETURN_STACK_OVERFLOWS" />
	<description>The number of (near) call instructions that cause the return address stack to overflow. When this happens, the oldest entry is discarded. This count may include speculatively executed calls.</description>
</event>

<event name="Instruction Cache Victims" abbreviation="IC victims" value="8b" >
	<op_name name="op" value="INSTRUCTION_CACHE_VICTIMS" />
	<description>The number of cachelines evicted from the instruction cache to the L2.</description>
</event>

<event name="Instruction Cache Lines Invalidated" abbreviation="IC lines invalidated" value="8c" >
	<mask value="0" name="Invalidating probe that did not hit any in-flight instructions" />
	<mask value="1" name="Invalidating probe that hit one or more in-flight instructions" />
	<mask value="2" name="SMC that did not hit any in-flight instructions" />
	<mask value="3" name="SMC that hit one or more in-flight instructions" />
	<op_name name="op" value="INSTRUCTION_CACHE_INVALIDATED" />
	<description>The number of instruction cache lines invalidated.</description>
</event>

<event name="ITLB Reloads" abbreviation="ITLB reloads" value="99" >
	<op_name name="op" value="ITLB_RELOADS" />
	<description>The number of ITLB reload requests.</description>
</event>

<event name="ITLB Reloads Aborted" abbreviation="ITLB reloads aborted" value="9a" >
	<op_name name="op" value="ITLB_RELOADS_ABORTED" />
	<description>The number of ITLB reloads aborted.</description>
</event>

</source>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; FR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

<source unit="FR">

<event name="Retired Instructions" abbreviation="Ret inst" value="c0" >
	<op_name name="op" value="RETIRED_INSTRUCTIONS" />
	<description>The number of instructions retired (execution completed and architectural state updated). This count includes exceptions and interrupts - each exception or interrupt is counted as one instruction.</description>
</event>

<event name="Retired uops" abbreviation="Ret uops" value="c1" >
	<op_name name="op" value="RETIRED_UOPS" />
	<description>The number of micro-ops retired. This includes all processor activity (instructions, exceptions, interrupts, microcode assists, etc.).</description>
</event>

<event name="Retired Branch Instructions" abbreviation="Ret branch" value="c2" >
	<op_name name="op" value="RETIRED_BRANCH_INSTRUCTIONS" />
	<description>The number of branch instructions retired. This includes all types of architectural control flow changes, including exceptions and interrupts.</description>
</event>

<event name="Retired Mispredicted Branch Instructions" abbreviation="Ret misp branch" value="c3" >
	<op_name name="op" value="RETIRED_MISPREDICTED_BRANCH_INSTRUCTIONS" />
	<description>The number of branch instructions retired, of any type, that are not correctly predicted. This includes those for which prediction is not attempted (far control transfers, exceptions and interrupts).</description>
</event>

<event name="Retired Taken Branch Instructions" abbreviation="Ret taken branch" value="c4" >
	<op_name name="op" value="RETIRED_TAKEN_BRANCH_INSTRUCTIONS" />
	<description>The number of taken branches retired. This includes all types of architectural control flow changes, including exceptions and interrupts.</description>
</event>

<event name="Retired Taken Branch Instructions Mispredicted" abbreviation="Ret taken branch misp" value="c5" >
	<op_name name="op" value="RETIRED_TAKEN_BRANCH_INSTRUCTIONS_MISPREDICTED" />
	<description>The number of retired taken branch instructions that are mispredicted.</description>
</event>

<event name="Retired Far Control Transfers" abbreviation="Ret far xfers" value="c6" >
	<op_name name="op" value="RETIRED_FAR_CONTROL_TRANSFERS" />
	<description>The number of far control transfers retired including far call/jump/return, IRET, SYSCALL and SYSRET, plus exceptions and interrupts. Far control transfers are not subject to branch prediction.</description>
</event>

<event name="Retired Branch Resyncs" abbreviation="Ret branch resyncs" value="c7" >
	<op_name name="op" value="RETIRED_BRANCH_RESYNCS" />
	<description>The number of resync branches. These reflect pipeline restarts due to certain microcode assists and events such as writes to the active instruction stream, among other things. Each occurrence reflects a restart penalty similar to a branch mispredict. This is relatively rare.</description>
</event>

<event name="Retired Near Returns" abbreviation="Ret near RET" value="c8" >
	<op_name name="op" value="RETIRED_NEAR_RETURNS" />
	<description>The number of near return instructions (RET or RET Iw) retired.</description>
</event>

<event name="Retired Near Returns Mispredicted" abbreviation="Ret near RET misp" value="c9" >
	<op_name name="op" value="RETIRED_NEAR_RETURNS_MISPREDICTED" />
	<description>The number of near returns retired that are not correctly predicted by the return address predictor. Each such mispredict incurs the same penalty as a mispredicted conditional branch instruction.</description>
</event>

<event name="Retired Indirect Branches Mispredicted" abbreviation="Ret ind branch misp" value="ca" >
	<op_name name="op" value="RETIRED_INDIRECT_BRANCHES_MISPREDICTED" />
	<description>The number of indirect branch instructions retired where the target address was not correctly predicted.</description>
</event>

<event name="Retired MMX(tm)/FP Instructions" abbreviation="Ret MMX/FP inst" value="cb" >
	<mask value="0" name="x87 instructions" />
	<mask value="1" name="MMX(tm) and 3DNow!(tm) instructions" />
	<mask value="2" name="SSE and SSE2 instructions" />
	<op_name name="op" value="RETIRED_MMX_FP_INSTRUCTIONS" />
	<description>The number of MMXTM, SSE or X87 instructions retired. The UnitMask allows the selection of the individual classes of instructions as given in the table. Each increment represents one complete instruction. Since this event includes non-numeric instructions it is not suitable for measuring MFLOPS.</description>
</event>

<event name="Interrupts-Masked Cycles" abbreviation="Int-masked cycles" value="cd" >
	<op_name name="op" value="INTERRUPTS_MASKED_CYCLES" />
	<description>The number of processor cycles where interrupts are masked (EFLAGS.IF = 0). Using edge-counting with this event gives the number of times IF is cleared; dividing the cycle-count value by this value gives the average length of time that interrupts are disabled on each instance. Compare the edge count with PMCx0CF to determine how often interrupts are disabled for interrupt handling vs. other reasons (e.g. critical sections).</description>
</event>

<event name="Interrupts-Masked Cycles with Interrupt Pending" abbreviation="Int-masked pending" value="ce" >
	<op_name name="op" value="INTERRUPTS_MASKED_CYCLES_WITH_INTERRUPT_PENDING" />
	<description>The number of processor cycles where interrupts are masked (EFLAGS.IF = 0) and an interrupt is pending. Using edge-counting with this event and comparing the resulting count with the edge count for PMCx0CD gives the proportion of interrupts for which handling is delayed due to prior interrupts being serviced, critical sections, etc. The cycle count value gives the total amount of time for such delays. The cycle count divided by the edge count gives the average length of each such delay.</description>
</event>

<event name="Interrupts Taken" abbreviation="Int taken" value="cf" >
	<op_name name="op" value="INTERRUPTS_TAKEN" />
	<description>The number of hardware interrupts taken. This does not include software interrupts (INT n instruction).</description>
</event>

<event name="Decoder Empty" abbreviation="Decoder empty" value="d0" >
	<op_name name="op" value="DECODER_EMPTY" />
	<description>The number of processor cycles where the decoder has nothing to dispatch (typically waiting on an instruction fetch that missed the Icache, or for the target fetch after a branch mispredict).</description>
</event>

<event name="Dispatch Stalls" abbreviation="Dispatch stalls" value="d1" >
	<op_name name="op" value="DISPATCH_STALLS" />
	<description>The number of processor cycles where the decoder is stalled for any reason (has one or more instructions ready but can't dispatch them due to resource limitations in execution). This is the combined effect of events D2h - DAh, some of which may overlap; this event reflects the net stall cycles. The more common stall conditions (events D5h, D6h, D7h, D8h, and to a lesser extent D2) may overlap considerably. The occurrence of these stalls is highly dependent on the nature of the code being executed (instruction mix, memory reference patterns, etc.).</description>
</event>

<event name="Dispatch Stall for Branch Abort to Retire" abbreviation="Stall branch abort" value="d2" >
	<op_name name="op" value="DISPATCH_STALL_FOR_BRANCH_ABORT" />
	<description>The number of processor cycles the decoder is stalled waiting for the pipe to drain after a mispredicted branch. This stall occurs if the corrected target instruction reaches the dispatch stage before the pipe has emptied. See PMCx0D1.</description>
</event>

<event name="Dispatch Stall for Serialization" abbreviation="Stall serialization" value="d3" >
	<op_name name="op" value="DISPATCH_STALL_FOR_SERIALIZATION" />
	<description>The number of processor cycles the decoder is stalled due to a serializing operation, which waits for the execution pipeline to drain. Relatively rare; mainly associated with system instructions. See PMCx0D1.</description>
</event>

<event name="Dispatch Stall for Segment Load" abbreviation="Stall seg load" value="d4" >
	<op_name name="op" value="DISPATCH_STALL_FOR_SEGMENT_LOAD" />
	<description>The number of processor cycles the decoder is stalled due to a segment load instruction being encountered while execution of a previous segment load operation is still pending. Relatively rare except in 16-bit code. See PMCx0D1.</description>
</event>

<event name="Dispatch Stall for Reorder Buffer Full" abbreviation="Stall reorder full" value="d5" >
	<op_name name="op" value="DISPATCH_STALL_FOR_REORDER_BUFFER_FULL" />
	<description>The number of processor cycles the decoder is stalled because the reorder buffer is full. May occur simultaneously with certain other stall conditions; see PMCx0D1.</description>
</event>

<event name="Dispatch Stall for Reservation Station Full" abbreviation="Stall res station full" value="d6" >
	<op_name name="op" value="DISPATCH_STALL_FOR_RESERVATION_STATION_FULL" />
	<description>The number of processor cycles the decoder is stalled because a required integer unit reservation stations is full. May occur simultaneously with certain other stall conditions; see PMCx0D1.</description>
</event>

<event name="Dispatch Stall for FPU Full" abbreviation="Stall FPU full" value="d7" >
	<op_name name="op" value="DISPATCH_STALL_FOR_FPU_FULL" />
	<description>The number of processor cycles the decoder is stalled because the scheduler for the Floating Point Unit is full. This condition can be caused by a lack of parallelism in FP-intensive code, or by cache misses on FP operand loads (which could also show up as PMCx0D8 instead, depending on the nature of the instruction sequences). May occur simultaneously with certain other stall conditions; see PMCx0D1.</description>
</event>

<event name="Dispatch Stall for LS Full" abbreviation="Stall LS full" value="d8" >
	<op_name name="op" value="DISPATCH_STALL_FOR_LS_FULL" />
	<description>The number of processor cycles the decoder is stalled because the Load/Store Unit is full. This generally occurs due to heavy cache miss activity. May occur simultaneously with certain other stall conditions; see PMCx0D1.</description>
</event>

<event name="Dispatch Stall Waiting for All Quiet" abbreviation="Stall waiting quiet" value="d9" >
	<op_name name="op" value="DISPATCH_STALL_WAITING_FOR_ALL_QUIET" />
	<description>The number of processor cycles the decoder is stalled waiting for all outstanding requests to the system to be resolved. Relatively rare; associated with certain system instructions and types of interrupts. May partially overlap certain other stall conditions; see PMCx0D1.</description>
</event>

<event name="Dispatch Stall for Far Transfer or Resync to Retire" abbreviation="Stall far/resync" value="da" >
	<op_name name="op" value="DISPATCH_STALL_FOR_FAR_TRANSFER_OR_RESYNC" />
	<description>The number of processor cycles the decoder is stalled waiting for the execution pipeline to drain before dispatching the target instructions of a far control transfer or a Resync (an instruction stream restart associated with certain microcode assists). Relatively rare; does not overlap with other stall conditions. See PMCx0D1.</description>
</event>

<event name="FPU Exceptions" abbreviation="FPU except" value="db" >
	<mask value="0" name="x87 reclass microfaults" />
	<mask value="1" name="SSE retype microfaults" />
	<mask value="2" name="SSE reclass microfaults" />
	<mask value="3" name="SSE and x87 microtraps" />
	<op_name name="op" value="FPU_EXCEPTIONS" />
	<description>The number of floating point unit exceptions for microcode assists. The UnitMask may be used to isolate specific types of exceptions.</description>
</event>

<event name="DR0 Breakpoint Matches" abbreviation="DR0 matches" value="dc" >
	<op_name name="op" value="DR0_BREAKPOINTS" />
	<description>The number of matches on the address in breakpoint register DR0, per the breakpoint type specified in DR7. The breakpoint does not have to be enabled. Each instruction breakpoint match incurs an overhead of about 120 cycles; load/store breakpoint matches do not incur any overhead.</description>
</event>

<event name="DR1 Breakpoint Matches" abbreviation="DR1 matches" value="dd" >
	<op_name name="op" value="DR1_BREAKPOINTS" />
	<description>The number of matches on the address in breakpoint register DR1. See notes for PMCx0DC.</description>
</event>

<event name="DR2 Breakpoint Matches" abbreviation="DR2 matches" value="de" >
	<op_name name="op" value="DR2_BREAKPOINTS" />
	<description>The number of matches on the address in breakpoint register DR2. See notes for PMCx0DC.</description>
</event>

<event name="DR3 Breakpoint Matches" abbreviation="DR3 matches" value="df" >
	<op_name name="op" value="DR3_BREAKPOINTS" />
	<description>The number of matches on the address in breakpoint register DR3. See notes for PMCx0DC.</description>
</event>

<event name="Retired x87 Floating Point Operations" abbreviation="Ret x87 FP ops" value="1c0" >
	<mask value="0" name="Add/subtract ops" />
	<mask value="1" name="Multiply ops" />
	<mask value="2" name="Divide ops" />
	<op_name name="op" value="RETIRED_X87_FLOATING_POINT_OPERATIONS" />
	<description>The number of x87 floating point ops that have retired.</description>
</event>

<event name="LFENCE Instructions Retired" abbreviation="LFENCE inst ret" value="1d3" >
	<op_name name="op" value="LFENCE_INSTRUCTIONS_RETIRED" />
	<description>The number of LFENCE instructions retired.</description>
</event>

<event name="SFENCE Instructions Retired" abbreviation="SFENCE inst ret" value="1d4" >
	<op_name name="op" value="SFENCE_INSTRUCTIONS_RETIRED" />
	<description>The number of SFENCE instructions retired. This counter only counts properly if MSRC001_0015[SlowSfence]=0.</description>
</event>

<event name="MFENCE Instructions Retired" abbreviation="MFENCE inst ret" value="1d5" >
	<op_name name="op" value="MFENCE_INSTRUCTIONS_RETIRED" />
	<description>The number of MFENCE instructions retired.</description>
</event>

</source>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; NB
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

<source unit="NB">

<event name="DRAM Accesses" abbreviation="DRAM accesses" value="e0" >
	<mask value="0" name="DCT0 Page hit" />
	<mask value="1" name="DCT0 Page Miss" />
	<mask value="2" name="DCT0 Page Conflict" />
	<mask value="3" name="DCT1 Page hit" />
	<mask value="4" name="DCT1 Page Miss" />
	<mask value="5" name="DCT1 Page Conflict" />
	<mask value="6" name="Write request" />
	<mask value="7" name="Read request" />
	<op_name name="op" value="DRAM_ACCESSES" />
	<description>The number of memory accesses performed by the local DRAM controller. The UnitMask may be used to isolate the different DRAM page access cases. Page miss cases incur an extra latency to open a page; page conflict cases incur both a page-close as well as page-open penalties. These penalties may be overlapped by DRAM accesses for other requests and don't necessarily represent lost DRAM bandwidth. The associated penalties are as follows: Page miss: Trcd (DRAM RAS-to-CAS delay), Page conflict: Trp + Trcd (DRAM row-precharge time plus RAS-to-CAS delay).</description>
</event>

<event name="DRAM Controller 0 Page Table Events" abbreviation="DCT0 page table events" value="e1" >
	<mask value="0" name="DCT0 Page Table Overflow" />
	<mask value="1" name="DCT0 Number of stale table entry hits" />
	<mask value="2" name="DCT0 Page table idle cycle limit incremented" />
	<mask value="3" name="DCT0 Page table idle cycle limit decremented" />
	<mask value="4" name="DCT0 Page table is closed due to row inactivity" />
	<op_name name="op" value="DCT0_PAGE_TABLE_EVENTS" />
	<description>The number of page table events in the local DRAM controller. This table maintains information about which DRAM pages are open. An overflow occurs when a request for a new page arrives when the page table becomes full, as the oldest entry is speculatively closed. Each occurrence reflects an access latency penalty equivalent to a page conflict.</description>
</event>

<event name="Memory Controller DRAM Command Slots Missed" abbreviation="DRAM cmd slot miss" value="e2" >
	<mask value="4" name="DCT0 RBD" />
	<mask value="5" name="DCT1 RBD" />
	<mask value="6" name="DCT0 Prefetch" />
	<mask value="7" name="DCT1 Prefetch" />
	<op_name name="op" value="MEMORY_CONTROLLER_SLOT_MISSED" />
	<description>Memory Controller DRAM Command Slots Missed.</description>
</event>

<event name="Memory Controller Turnarounds" abbreviation="Turnarounds" value="e3" >
	<mask value="0" name="DCT0 read-to-write turnaround" />
	<mask value="1" name="DCT0 write-to-read turnaround" />
	<mask value="3" name="DCT1 read-to-write turnaround" />
	<mask value="4" name="DCT1 write-to-read turnaround" />
	<op_name name="op" value="MEMORY_CONTROLLER_TURNAROUNDS" />
	<description>The number of turnarounds on the local DRAM data bus. The UnitMask may be used to isolate the different cases. These represent lost DRAM bandwidth, which may be calculated as follows (in bytes per occurrence): DIMM turnaround: DRAM_width_in_bytes * 2 edges_per_memclk * 2; R/W turnaround: DRAM_width_in_bytes * 2 edges_per_memclk * 1; R/W turnaround: DRAM_width_in_bytes * 2 edges_per_memclk * (Tcl-1); where DRAM_width_in_bytes is 8 or 16 (for single- or dual-channel systems), and Tcl is the CAS latency of the DRAM in memory system clock cycles (where the memory clock for DDR-400, or PC3200 DIMMS, for example, would be 200 MHz).</description>
</event>

<event name="Memory Controller RBD Queue Events" abbreviation="RBD queue events" value="e4" >
	<mask value="2" name="D18F2x[1,0]94[DcqBypassMax] counter reached" />
	<mask value="3" name="Bank closed due to bank conflict with request in the RBD queue" />
	<op_name name="op" value="MEMORY_CONTROLLER_RBD_QUEUE_EVENTS" />
	<description>Memory Controller RBD Queue Events.</description>
</event>

<event name="DRAM Controller 1 Page Table Events" abbreviation="DCT1 page table events" value="e5" >
	<mask value="0" name="DCT1 Page Table Overflow" />
	<mask value="1" name="DCT1 Number of stale table entry hits" />
	<mask value="2" name="DCT1 Page table idle cycle limit incremented" />
	<mask value="3" name="DCT1 Page table idle cycle limit decremented" />
	<mask value="4" name="DCT1 Page table is closed due to row inactivity" />
	<op_name name="op" value="DCT1_PAGE_TABLE_EVENTS" />
	<description>The number of page table events in the local DRAM controller. This table maintains information about which DRAM pages are open. An overflow occurs when a request for a new page arrives when the page table becomes full, as the oldest entry is speculatively closed. Each occurrence reflects an access latency penalty equivalent to a page conflict.</description>
</event>

<event name="Thermal Status" abbreviation="Thermal status" value="e8" >
	<mask value="0" name="MEMHOT_L assertions" />
	<mask value="2" name="Number of times the HTC transitions from inactive to active" />
	<mask value="5" name="Number of clocks HTC P-state is inactive" />
	<mask value="6" name="Number of clocks HTC P-state is active" />
	<mask value="7" name="PROCHOT_L asserted by external source and caused a P-state change" />
	<op_name name="op" value="THERMAL_STATUS" />
	<description>Thermal Status.</description>
</event>

<event name="CPU/IO Requests to Memory/IO" abbreviation="CPU/IO req mem/IO" value="e9" >
	<mask value="0" name="IO to IO" />
	<mask value="1" name="IO to Mem" />
	<mask value="2" name="CPU to IO" />
	<mask value="3" name="CPU to Mem" />
	<op_name name="op" value="CPU_IO_REQUESTS_TO_MEMORY_IO" />
	<description>These events reflect request flow between units, as selected by the UnitMask. It is not possible to tell from these events how much data is going in which direction, as there is no distinction between reads and writes. Also, particularly for IO, the requests may be for varying amounts of data, anywhere from one to sixty-four bytes.</description>
</event>

<event name="Cache Block Commands" abbreviation="Cache block cmd" value="ea" >
	<mask value="0" name="Victim Block (Writeback)" />
	<mask value="2" name="Read Block (Dcache load miss refill)" />
	<mask value="3" name="Read Block Shared (Icache refill)" />
	<mask value="4" name="Read Block Modified (Dcache store miss refill)" />
	<mask value="5" name="Change to Dirty (first store to clean block already in cache)" />
	<op_name name="op" value="CACHE_BLOCK_COMMANDS" />
	<description>The number of requests made to the system for cache line transfers or coherency state changes, by request type. Each increment represents one cache line transfer, except for Change-to-Dirty. If a Change-to-Dirty request hits on a line in another processor's cache that's in the Owned state, it causes a cache line transfer, otherwise there is no data transfer associated with Change-to-Dirty requests.</description>
</event>

<event name="Sized Commands" abbreviation="Sized cmd" value="eb" >
	<mask value="0" name="Non-Posted SzWr Byte (1-32 bytes)" />
	<mask value="1" name="Non-Posted SzWr DW (1-16 dwords)" />
	<mask value="2" name="Posted SzWr Byte (1-32 bytes)" />
	<mask value="3" name="Posted SzWr DW (1-16 dwords)" />
	<mask value="4" name="SzRd Byte (4 bytes)" />
	<mask value="5" name="SzRd DW (1-16 dwords)" />
	<op_name name="op" value="SIZED_COMMANDS" />
	<description>The number of Sized Read/Write commands handled by the System Request Interface (local processor and hostbridge interface to the system). These commands may originate from the processor or hostbridge. See PMCx0EC, which provides a separate measure of Hostbridge accesses.</description>
</event>

<event name="Probe Responses and Upstream Requests" abbreviation="Probe resp/up req" value="ec" >
	<mask value="0" name="Probe miss" />
	<mask value="1" name="Probe hit clean" />
	<mask value="2" name="Probe hit dirty without memory cancel" />
	<mask value="3" name="Probe hit dirty with memory cancel" />
	<mask value="4" name="Upstream high priority reads" />
	<mask value="5" name="Upstream low priority reads" />
	<mask value="7" name="Upstream low priority writes" />
	<op_name name="op" value="PROBE_RESPONSES_AND_UPSTREAM_REQUESTS" />
	<description>This covers two unrelated sets of events: cache probe results, and requests received by the hostbridge from devices on a non-coherent link. Probe results: These events reflect the results of probes sent from a memory controller to local caches. They provide an indication of the degree data and code is shared between processors (or moved between processors due to process migration). The dirty-hit events indicate the transfer of a 64-byte cache line to the requester (for a read or cache refill) or the target memory (for a write). The system bandwidth used by these, in terms of bytes per unit of time, may be calculated as 64 times the event count, divided by the elapsed time. Sized writes to memory that cover a full cache line do not incur this cache line transfer -- they simply invalidate the line and are reported as clean hits. Cache line transfers occur for Change2Dirty requests that hit cache lines in the Owned state. (Such cache lines are counted as Modified-state refills for PMCx06C, System Read Responses.) Upstream requests: The upstream read and write events reflect requests originating from a device on a local link. DMA accesses may be anywhere from 1 to 64 bytes in size, but may be dominated by a particular size such as 32 or 64 bytes, depending on the nature of the devices.</description>
</event>

<event name="DEV Events" abbreviation="DEV events" value="ee" >
	<mask value="4" name="DEV hit" />
	<mask value="5" name="DEV miss" />
	<mask value="6" name="DEV error" />
	<op_name name="op" value="DEV_EVENTS" />
	<description>DEV Events.</description>
</event>

<event name="Memory Controller Requests" abbreviation="MCT Requests" value="1f0" >
	<mask value="3" name="32 Bytes Sized Writes" />
	<mask value="4" name="64 Bytes Sized Writes" />
	<mask value="5" name="32 Bytes Sized Reads" />
	<mask value="6" name="64 Byte Sized Reads" />
	<op_name name="op" value="MEMORY_CONTROLLER_REQUESTS" />
	<description>Sized Read/Write activity: The Sized Read/Write events reflect 32- or 64-byte transfers (as opposed to other sizes which could be anywhere between 1 and 64 bytes), from either the processor or the Hostbridge. Such accesses from the processor would be due only to write combining buffer flushes, where 32-byte accesses would reflect flushes of partially-filled buffers. Event 65h provides a count of sized write requests associated with WC buffer flushes; comparing that with counts for these events (providing there is very little Hostbridge activity at the same time) give an indication of how efficiently the write combining buffers are being used. Event 65h may also be useful in factoring out WC flushes when comparing these events with the Upstream Requests component of event ECh.</description>
</event>

</source>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; NB
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

<source unit="NB">

<event name="Sideband Signals and Special Cycles" abbreviation="Sideband signals" value="1e9" >
	<mask value="1" name="STOPGRANT" />
	<mask value="2" name="SHUTDOWN" />
	<mask value="3" name="WBINVD" />
	<mask value="4" name="INVD" />
	<op_name name="op" value="SIDEBAND_SIGNALS" />
	<description>Sideband Signals and Special Cycles.</description>
</event>

<event name="Interrupt Events" abbreviation="Interrupt events" value="1ea" >
	<mask value="0" name="Fixed and LPA" />
	<mask value="1" name="LPA" />
	<mask value="2" name="SMI" />
	<mask value="3" name="NMI" />
	<mask value="4" name="INIT" />
	<mask value="5" name="STARTUP" />
	<mask value="6" name="INT" />
	<mask value="7" name="EOI" />
	<op_name name="op" value="INTERRUPT_EVENTS" />
	<description>Interrupt Events.</description>
</event>

</source>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; FR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

<source unit="FR">

<event name="All IBS fetch samples" abbreviation="IBS fetch" value="f000" >
	<op_name name="op" value="IBS_FETCH_ALL" />
	<description>The number of all IBS fetch samples. This derived event counts the number of all IBS fetch samples that were collected including IBS-killed fetch samples.</description>
</event>

<event name="IBS fetch killed" abbreviation="IBS fetch killed" value="f001" >
	<op_name name="op" value="IBS_FETCH_KILLED" />
	<description>The number of IBS sampled fetches that were killed fetches. A fetch operation is killed if the fetch did not reach ITLB or IC access. The number of killed fetch samples is not generally useful for analysis and are filtered out in other derived IBS fetch events (except Event Select 0xF000 which counts all IBS fetch samples including IBS killed fetch samples.)</description>
</event>

<event name="IBS fetch attempted" abbreviation="IBS fetch attempt" value="f002" >
	<op_name name="op" value="IBS_FETCH_ATTEMPTED" />
	<description>The number of IBS sampled fetches that were not killed fetch attempts. This derived event measures the number of useful fetch attempts and does not include the number of IBS killed fetch samples. This event should be used to compute ratios such as the ratio of IBS fetch IC misses to attempted fetches. The number of attempted fetches should equal the sum of the number of completed fetches and the number of aborted fetches.</description>
</event>

<event name="IBS fetch completed" abbreviation="IBS fetch comp" value="f003" >
	<op_name name="op" value="IBS_FETCH_COMPLETED" />
	<description>The number of IBS sampled fetches that completed. A fetch is completed if the attempted fetch delivers instruction data to the instruction decoder. Although the instruction data was delivered, it may still not be used (e.g., the instruction data may have been on the "wrong path" of an incorrectly predicted branch.)</description>
</event>

<event name="IBS fetch aborted" abbreviation="IBS fetch abort" value="f004" >
	<op_name name="op" value="IBS_FETCH_ABORTED" />
	<description>The number of IBS sampled fetches that aborted. An attempted fetch is aborted if it did not complete and deliver instruction data to the decoder. An attempted fetch may abort at any point in the process of fetching instruction data. An abort may be due to a branch redirection as the result of a mispredicted branch. The number of IBS aborted fetch samples is a lower bound on the amount of unsuccessful, speculative fetch activity. It is a lower bound since the instruction data delivered by completed fetches may not be used.</description>
</event>

<event name="IBS ITLB hit" abbreviation="IBS L1 ITLB hit" value="f005" >
	<op_name name="op" value="IBS_FETCH_ITLB_HITS" />
	<description>The number of IBS attempted fetch samples where the fetch operation initially hit in the L1 ITLB (Instruction Translation Lookaside Buffer).</description>
</event>

<event name="IBS L1 ITLB misses (and L2 ITLB hits)" abbreviation="IBS ITLB L1M L2H" value="f006" >
	<op_name name="op" value="IBS_FETCH_L1_ITLB_MISSES_L2_ITLB_HITS" />
	<description>The number of IBS attempted fetch samples where the fetch operation initially missed in the L1 ITLB and hit in the L2 ITLB.</description>
</event>

<event name="IBS L1 L2 ITLB miss" abbreviation="IBS ITLB L1M L2M" value="f007" >
	<op_name name="op" value="IBS_FETCH_L1_ITLB_MISSES_L2_ITLB_MISSES" />
	<description>The number of IBS attempted fetch samples where the fetch operation initially missed in both the L1 ITLB and the L2 ITLB.</description>
</event>

<event name="IBS instruction cache misses" abbreviation="IBS IC miss" value="f008" >
	<op_name name="op" value="IBS_FETCH_ICACHE_MISSES" />
	<description>The number of IBS attempted fetch samples where the fetch operation initially missed in the IC (instruction cache).</description>
</event>

<event name="IBS instruction cache hit" abbreviation="IBS IC hit" value="f009" >
	<op_name name="op" value="IBS_FETCH_ICACHE_HITS" />
	<description>The number of IBS attempted fetch samples where the fetch operation initially hit in the IC.</description>
</event>

<event name="IBS 4K page translation" abbreviation="IBS 4K page" value="f00a" >
	<op_name name="op" value="IBS_FETCH_4K_PAGE" />
	<description>The number of IBS attempted fetch samples where the fetch operation produced a valid physical address (i.e., address translation completed successfully) and used a 4-KByte page entry in the L1 ITLB.</description>
</event>

<event name="IBS 2M page translation" abbreviation="IBS 2M page" value="f00b" >
	<op_name name="op" value="IBS_FETCH_2M_PAGE" />
	<description>The number of IBS attempted fetch samples where the fetch operation produced a valid physical address (i.e., address translation completed successfully) and used a 2-MByte page entry in the L1 ITLB.</description>
</event>

<event name="IBS fetch latency" abbreviation="IBS fetch lat" value="f00e" >
	<op_name name="op" value="IBS_FETCH_LATENCY" />
	<description>The total latency of all IBS attempted fetch samples. Divide the total IBS fetch latency by the number of IBS attempted fetch samples to obtain the average latency of the attempted fetches that were sampled.</description>
</event>

<event name="All IBS op samples" abbreviation="IBS all ops" value="f100" >
	<op_name name="op" value="IBS_OP_ALL" />
	<description>The number of all IBS op samples that were collected. These op samples may be branch ops, resync ops, ops that perform load/store operations, or undifferentiated ops (e.g., those ops that perform arithmetic operations, logical operations, etc.). IBS collects data for retired ops. No data is collected for ops that are aborted due to pipeline flushes, etc. Thus, all sampled ops are architecturally significant and contribute to the successful forward progress of executing programs.</description>
</event>

<event name="IBS tag-to-retire cycles" abbreviation="IBS tag-to-ret" value="f101" >
	<op_name name="op" value="IBS_OP_TAG_TO_RETIRE" />
	<description>The total number of tag-to-retire cycles across all IBS op samples. The tag-to-retire time of an op is the number of cycles from when the op was tagged (selected for sampling) to when the op retired.</description>
</event>

<event name="IBS completion-to-retire cycles" abbreviation="IBS comp-to-ret" value="f102" >
	<op_name name="op" value="IBS_OP_COMP_TO_RET" />
	<description>The total number of completion-to-retire cycles across all IBS op samples. The completion-to-retire time of an op is the number of cycles from when the op completed to when the op retired.</description>
</event>

<event name="IBS branch op" abbreviation="IBS BR" value="f103" >
	<op_name name="op" value="IBS_OP_BRANCH_RETIRED" />
	<description>The number of IBS retired branch op samples. A branch operation is a change in program control flow and includes unconditional and conditional branches, subroutine calls and subroutine returns. Branch ops are used to implement AMD64 branch semantics.</description>
</event>

<event name="IBS mispredicted branch op" abbreviation="IBS misp BR" value="f104" >
	<op_name name="op" value="IBS_OP_MISPREDICTED_BRANCH" />
	<description>The number of IBS samples for retired branch operations that were mispredicted. This event should be used to compute the ratio of mispredicted branch operations to all branch operations.</description>
</event>

<event name="IBS taken branch op" abbreviation="IBS taken BR" value="f105" >
	<op_name name="op" value="IBS_OP_TAKEN_BRANCH" />
	<description>The number of IBS samples for retired branch operations that were taken branches.</description>
</event>

<event name="IBS mispredicted taken branch op" abbreviation="IBS misp taken BR" value="f106" >
	<op_name name="op" value="IBS_OP_MISPREDICTED_BRANCH_TAKEN" />
	<description>The number of IBS samples for retired branch operations that were mispredicted taken branches.</description>
</event>

<event name="IBS return op" abbreviation="IBS RET" value="f107" >
	<op_name name="op" value="IBS_OP_RETURNS" />
	<description>The number of IBS retired branch op samples where the operation was a subroutine return. These samples are a subset of all IBS retired branch op samples.</description>
</event>

<event name="IBS mispredicted return op" abbreviation="IBS misp RET" value="f108" >
	<op_name name="op" value="IBS_OP_MISPREDICTED_RETURNS" />
	<description>The number of IBS retired branch op samples where the operation was a mispredicted subroutine return. This event should be used to compute the ratio of mispredicted returns to all subroutine returns.</description>
</event>

<event name="IBS resync op" abbreviation="IBS resync" value="f109" >
	<op_name name="op" value="IBS_OP_RESYNC" />
	<description>The number of IBS resync op samples. A resync op is only found in certain microcoded AMD64 instructions and causes a complete pipeline flush.</description>
</event>

<event name="IBS all load store ops" abbreviation="IBS load/store" value="f200" >
	<op_name name="op" value="IBS_OP_ALL_LOAD_STORE" />
	<description>The number of IBS op samples for ops that perform either a load and/or store operation. An AMD64 instruction may be translated into one ("single fastpath"), two ("double fastpath"), or several ("vector path") ops. Each op may perform a load operation, a store operation or both a load and store operation (each to the same address). Some op samples attributed to an AMD64 instruction may perform a load/store operation while other op samples attributed to the same instruction may not. Further, some branch instructions perform load/store operations. Thus, a mix of op sample types may be attributed to a single AMD64 instruction depending upon the ops that are issued from the AMD64 instruction and the op types.</description>
</event>

<event name="IBS load ops" abbreviation="IBS load" value="f201" >
	<op_name name="op" value="IBS_OP_LOAD" />
	<description>The number of IBS op samples for ops that perform a load operation.</description>
</event>

<event name="IBS store ops" abbreviation="IBS store" value="f202" >
	<op_name name="op" value="IBS_OP_STORE" />
	<description>The number of IBS op samples for ops that perform a store operation.</description>
</event>

<event name="IBS L1 DTLB hit" abbreviation="IBS L1 DTLB hit" value="f203" >
	<op_name name="op" value="IBS_OP_L1_DTLB_HITS" />
	<description>The number of IBS op samples where either a load or store operation initially hit in the L1 DTLB (data translation lookaside buffer).</description>
</event>

<event name="IBS L1 DTLB misses L2 hits" abbreviation="IBS DTLB L1M L2H" value="f204" >
	<op_name name="op" value="IBS_OP_L1_DTLB_MISS_L2_DTLB_HIT" />
	<description>The number of IBS op samples where either a load or store operation initially missed in the L1 DTLB and hit in the L2 DTLB.</description>
</event>

<event name="IBS L1 and L2 DTLB misses" abbreviation="IBS DTLB L1M L2M" value="f205" >
	<op_name name="op" value="IBS_OP_L1_L2_DTLB_MISS" />
	<description>The number of IBS op samples where either a load or store operation initially missed in both the L1 DTLB and the L2 DTLB.</description>
</event>

<event name="IBS data cache misses" abbreviation="IBS DC miss" value="f206" >
	<op_name name="op" value="IBS_OP_DATA_CACHE_MISS" />
	<description>The number of IBS op samples where either a load or store operation initially missed in the data cache (DC).</description>
</event>

<event name="IBS data cache hits" abbreviation="IBS DC hit" value="f207" >
	<op_name name="op" value="IBS_OP_DATA_HITS" />
	<description>The number of IBS op samples where either a load or store operation initially hit in the data cache (DC).</description>
</event>

<event name="IBS misaligned data access" abbreviation="IBS misalign acc" value="f208" >
	<op_name name="op" value="IBS_OP_MISALIGNED_DATA_ACC" />
	<description>The number of IBS op samples where either a load or store operation caused a misaligned access (i.e., the load or store operation crossed a 128-bit boundary).</description>
</event>

<event name="IBS bank conflict on load op" abbreviation="IBS bank conf load" value="f209" >
	<op_name name="op" value="IBS_OP_BANK_CONF_LOAD" />
	<description>The number of IBS op samples where either a load or store operation caused a bank conflict with a load operation.</description>
</event>

<event name="IBS bank conflict on store op" abbreviation="IBS bank conf store" value="f20a" >
	<op_name name="op" value="IBS_OP_BANK_CONF_STORE" />
	<description>The number of IBS op samples where either a load or store operation caused a bank conflict with a store operation.</description>
</event>

<event name="IBS store-to-load forwarded" abbreviation="IBS forwarded" value="f20b" >
	<op_name name="op" value="IBS_OP_FORWARD" />
	<description>The number of IBS op samples where data for a load operation was forwarded from a store operation.</description>
</event>

<event name="IBS store-to-load cancelled" abbreviation="IBS STLF cancelled" value="f20c" >
	<op_name name="op" value="IBS_OP_CANCELLED" />
	<description>The number of IBS op samples where data forwarding to a load operation from a store was cancelled.</description>
</event>

<event name="IBS UC memory access" abbreviation="IBS UC mem acc" value="f20d" >
	<op_name name="op" value="IBS_OP_DCUC_MEM_ACC" />
	<description>The number of IBS op samples where a load or store operation accessed uncacheable (UC) memory.</description>
</event>

<event name="IBS WC memory access" abbreviation="IBS WC mem acc" value="f20e" >
	<op_name name="op" value="IBS_OP_DCWC_MEM_ACC" />
	<description>The number of IBS op samples where a load or store operation accessed write combining (WC) memory.</description>
</event>

<event name="IBS locked operation" abbreviation="IBS locked op" value="f20f" >
	<op_name name="op" value="IBS_OP_LOCKED" />
	<description>The number of IBS op samples where a load or store operation was a locked operation.</description>
</event>

<event name="IBS MAB hit" abbreviation="IBS MAB hit" value="f210" >
	<op_name name="op" value="IBS_OP_MAB_HIT" />
	<description>The number of IBS op samples where a load or store operation hit an already allocated entry in the Miss Address Buffer (MAB).</description>
</event>

<event name="IBS L1 DTLB 4K page" abbreviation="IBS L1 DTLB 4K" value="f211" >
	<op_name name="op" value="IBS_OP_L1_DTLB_4K" />
	<description>The number of IBS op samples where a load or store operation produced a valid linear (virtual) address and a 4-KByte page entry in the L1 DTLB was used for address translation.</description>
</event>

<event name="IBS L1 DTLB 2M page" abbreviation="IBS L1 DTLB 2M" value="f212" >
	<op_name name="op" value="IBS_OP_L1_DTLB_2M" />
	<description>The number of IBS op samples where a load or store operation produced a valid linear (virtual) address and a 2-MByte page entry in the L1 DTLB was used for address translation.</description>
</event>

<event name="IBS L1 DTLB 1G page" abbreviation="IBS L1 DTLB 1G" value="f213" >
	<op_name name="op" value="IBS_OP_L1_DTLB_1G" />
	<description>The number of IBS op samples where a load or store operation produced a valid linear (virtual) address and a 1-GByte page entry in the L1 DTLB was used for address translation.</description>
</event>

<event name="IBS L2 DTLB 4K page" abbreviation="IBS L2 DTLB 4K" value="f215" >
	<op_name name="op" value="IBS_OP_L2_DTLB_4K" />
	<description>The number of IBS op samples where a load or store operation produced a valid linear (virtual) address, hit the L2 DTLB, and used a 4 KByte page entry for address translation.</description>
</event>

<event name="IBS L2 DTLB 2M page" abbreviation="IBS L2 DTLB 2M" value="f216" >
	<op_name name="op" value="IBS_OP_L2_DTLB_2M" />
	<description>The number of IBS op samples where a load or store operation produced a valid linear (virtual) address, hit the L2 DTLB, and used a 2-MByte page entry for address translation.</description>
</event>

<event name="IBS L2 DTLB 1G page" abbreviation="IBS L2 DTLB 1G" value="f217" >
	<op_name name="op" value="IBS_OP_L2_DTLB_1G" />
	<description>The number of IBS op samples where a load or store operation produced a valid linear (virtual) address, hit the L2 DTLB, and used a 1-GByte page entry for address translation.</description>
</event>

<event name="IBS data cache miss load latency" abbreviation="IBS DC miss lat" value="f219" >
	<op_name name="op" value="IBS_OP_DC_LOAD_LAT" />
	<description>The total DC miss load latency (in processor cycles) across all IBS op samples that performed a load operation and missed in the data cache. The miss latency is the number of clock cycles from when the data cache miss was detected to when data was delivered to the core. Divide the total DC miss load latency by the number of data cache misses to obtain the average DC miss load latency.</description>
</event>

<event name="IBS Northbridge local" abbreviation="IBS NB local" value="f240" >
	<op_name name="op" value="IBS_OP_NB_LOCAL_ONLY" />
	<description>The number of IBS op samples where a load operation was serviced from the local processor. Northbridge IBS data is only valid for load operations that miss in both the L1 data cache and the L2 data cache. If a load operation crosses a cache line boundary, then the IBS data reflects the access to the lower cache line.</description>
</event>

<event name="IBS Northbridge remote" abbreviation="IBS NB remote" value="f241" >
	<op_name name="op" value="IBS_OP_NB_REMOTE_ONLY" />
	<description>The number of IBS op samples where a load operation was serviced from a remote processor.</description>
</event>

<event name="IBS Northbridge local L3" abbreviation="IBS NB local L3" value="f242" >
	<op_name name="op" value="IBS_OP_NB_LOCAL_L3" />
	<description>The number of IBS op samples where a load operation was serviced by the local L3 cache.</description>
</event>

<event name="IBS Northbridge local core L1 or L2 cache" abbreviation="IBS NB local cache" value="f243" >
	<op_name name="op" value="IBS_OP_NB_LOCAL_CACHE" />
	<description>The number of IBS op samples where a load operation was serviced by a cache (L1 data cache or L2 cache) belonging to a local core which is a sibling of the core making the memory request.</description>
</event>

<event name="IBS Northbridge local core L1, L2, L3 cache" abbreviation="IBS NB remote cache" value="f244" >
	<op_name name="op" value="IBS_OP_NB_REMOTE_CACHE" />
	<description>The number of IBS op samples where a load operation was serviced by a remote L1 data cache, L2 cache or L3 cache after traversing one or more coherent HyperTransport links.</description>
</event>

<event name="IBS Northbridge local DRAM" abbreviation="IBS NB local DRAM" value="f245" >
	<op_name name="op" value="IBS_OP_NB_LOCAL_DRAM" />
	<description>The number of IBS op samples where a load operation was serviced by local system memory (local DRAM via the memory controller).</description>
</event>

<event name="IBS Northbridge remote DRAM" abbreviation="IBS NB remote DRAM" value="f246" >
	<op_name name="op" value="IBS_OP_NB_REMOTE_DRAM" />
	<description>The number of IBS op samples where a load operation was serviced by remote system memory (after traversing one or more coherent HyperTransport links and through a remote memory controller).</description>
</event>

<event name="IBS Northbridge local APIC MMIO Config PCI" abbreviation="IBS NB local other" value="f247" >
	<op_name name="op" value="IBS_OP_NB_LOCAL_OTHER" />
	<description>The number of IBS op samples where a load operation was serviced from local MMIO, configuration or PCI space, or from the local APIC.</description>
</event>

<event name="IBS Northbridge remote APIC MMIO Config PCI" abbreviation="IBS NB remote other" value="f248" >
	<op_name name="op" value="IBS_OP_NB_REMOTE_OTHER" />
	<description>The number of IBS op samples where a load operation was serviced from remote MMIO, configuration or PCI space.</description>
</event>

<event name="IBS Northbridge cache modified state" abbreviation="IBS NB cache Modified" value="f249" >
	<op_name name="op" value="IBS_OP_NB_CACHE_MODIFIED" />
	<description>The number of IBS op samples where a load operation was serviced from local or remote cache, and the cache hit state was the Modified (M) state.</description>
</event>

<event name="IBS Northbridge cache owned state" abbreviation="IBS NB cache Owned" value="f24a" >
	<op_name name="op" value="IBS_OP_NB_CACHE_OWNED" />
	<description>The number of IBS op samples where a load operation was serviced from local or remote cache, and the cache hit state was the Owned (O) state.</description>
</event>

<event name="IBS Northbridge local cache latency" abbreviation="IBS NB local lat" value="f24b" >
	<op_name name="op" value="IBS_OP_NB_LOCAL_CACHE_LAT" />
	<description>The total data cache miss latency (in processor cycles) for load operations that were serviced by the local processor.</description>
</event>

<event name="IBS Northbridge remote cache latency" abbreviation="IBS NB remote lat" value="f24c" >
	<op_name name="op" value="IBS_OP_NB_REMOTE_CACHE_LAT" />
	<description>The total data cache miss latency (in processor cycles) for load operations that were serviced by a remote processor.</description>
</event>

<event name="Cache Line Utilization Percentage" abbreviation="Cache Line Utilization" value="ff00" >
	<op_name name="op" value="PERCENTAGE_CACHE_LINE_UTILIZATION" />
</event>

<event name="Line Boundary Crossings" abbreviation="Line Boundary Crossings" value="ff01" >
	<op_name name="op" value="LINE_BOUNDARY_CROSSINGS" />
</event>

<event name="Bytes/L1 Eviction" abbreviation="Bytes/L1 Eviction" value="ff02" >
	<op_name name="op" value="BYTES_PER_L1_EVICTION" />
</event>

<event name="Accesses/L1 Eviction" abbreviation="Accesses/L1 Eviction" value="ff03" >
	<op_name name="op" value="ACCESSES_PER_L1_EVICTION" />
</event>

<event name="L1 Evictions" abbreviation="L1 Evictions" value="ff04" >
	<op_name name="op" value="L1_EVICTION_COUNT" />
</event>

<event name="Accesses" abbreviation="Accesses" value="ff05" >
	<op_name name="op" value="L1_ACCESS_COUNT" />
</event>

<event name="Bytes Accessed" abbreviation="Bytes Accessed" value="ff06" >
	<op_name name="op" value="L1_BYTE_ACCESSED_COUNT" />
</event>

</source>

</cpu_events>
